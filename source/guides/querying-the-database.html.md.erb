---
title: Querying the Database
order: 6
intro: >
  Lucky comes with a flexible and type safe ORM called LuckyRecord. It allows for
  preloading and querying associations without worrying about incorrect types or
  renamed columns.
---

## Setting up a model

We'll assume we ran a migration that created a name and age column. The name is
a `String` and the age is an `Int32?`. The `age` column allows null because the
type is nilable (designated by the `?`).

Let's add the model for it:

```
# src/models/user.cr
class User < BaseModel
  table :users do
    field name : String
    field age : Int32?
  end
end
```

> You can add a `?` to the end of any type to mark it as nilable.

### Field types

You can use the following types in your fields.

* `String` - `text` column type. In Postgres [`text` can store strings of any length](https://stackoverflow.com/questions/4848964/postgresql-difference-between-text-and-varchar-character-varying)
* `Int32` - `int` column type.
* `Time` - `timestamp` column type.
* `Float` - `decimal` column type.
* `Bool` - `bool` column type.

## Querying the database

When you define a model, Lucky creates a query class that you can use to get
users from the database. The class is always called `{ModelName}::BaseQuery` .

To use it, let's create a query object that inherits from the one generated by
Lucky.

```
# src/queries/user_query.cr
class UserQuery < User::BaseQuery
end
```

`User::BaseQuery` has methods for querying and retrieving users such as:

* `first`
* `find`
* All methods included by `Enumerable(T)`, such as `each` and `map`

It also has methods for ordering and adding where clauses. These are generated
based on the fields defined in your model.

For the model we defined Lucky would generate:

* `created_at` (automatically added)
* `updated_at` (automatically added)
* `id` (automatically added)
* `age`
* `name`

## Where clauses

You can use the methods generated by Lucky to create where clauses.

```
# SELECT * FROM users where name='Paul';
UserQuery.new.name("Paul")

# SELECT * FROM users where age=28;
UserQuery.new.age(28)
```

### Parsing query params

Lucky will accept the type defined in the model (e.g. `Int32` for `age`) or a
`String`. If you pass it a `String` then Lucky will attempt to parse it and use
the type defined for the field.

For example:

```
# Lucky parses the string and use an Int32 in the query
UserQuery.new.age("30")

# Won't accept other types
# Fails at compile time because you can't pass a Float
UserQuery.new.age(30.0)
```

> Note that this will change in the future but this is the current behavior. In
the future only the defined type (`Int32` in this example) will work. You will
then need to manually parse it. Don't worry though, Lucky will add some helpers
to actions and the model to make this easy and maintainable.

## Ordering results

````
UserQuery.new.age.desc_order
# or
UserQuery.new.age.asc_order
````

## Chaining methods

You can chain where clauses and most other query methods.

```
UserQuery.new.age.gt(28).age.desc_order
```

## Running the query

The query does not actually hit the database until a method is called to fetch a
result or iterate over results.

Some of the most common methods are:

* `first`
* `find`
* `each`

For example:

```
# The query is not yet run
query = UserQuery.new
query.name("Sally")
query.age(30)

# The query will run once `each` is called
# Results are not cached so a request will be made every time you call `each`
query.each do |user|
  pp user.name
end
```

## Finding by ID

```
id = 1
UserQuery.new.find(id)

# You can also chain methods before calling find, first, etc.
UserQuery.new.age(30).find(1)
```

## Type specific query methods

The previous section mostly focused on simple equality queries, but you can also
do more advanced queries depending on the field type.

### All types

* `is`
* `desc_order`
* `asc_order`

### String

* `like`
* `ilike`
* `lower`

### Int32 and Time

* `gt`
* `gte`
* `lt`
* `lte`

### Examples

```
UserQuery.new.age.gte(18).name.lower.is("sally")
```

## Using scopes

Generally it's best to name your query methods so they are easy to understand
and reuse across your app. In Lucky, this is done by extracting methods on the
query object.

Here's an example:

```
class UserQuery < User::BaseQuery
  def adults
    age.gte(18)
  end

  def search(name)
    ilike("#{name}%")
  end
end

UserQuery.new.adults.search("Sal")
```

## Using associations

LuckyRecord currently has limited support for associations, but more features
will be added soon.

Right now you can define `has_many` and `belongs_to` associations.

```
class User < BaseModel
  table users do
    has_many tasks : Task
    belongs_to company : Company
  end
end

# Will return the company associated with the User
UserQuery.new.find(1).company
```

> Preloading associations to avoid N+1 queries will be coming soon.
