---
title: Querying the Database
order: 6
intro: >
  Lucky comes with a flexible and type safe ORM called LuckyRecord. It allows for
  preloading and querying associations without worrying about incorrect types or
  renamed columns.
---

## Setting up a model

Let’s set up a model for users in our database. We'll assume we ran a migration
that created a name and age column. The name is NOT NULL.

Let’s add the model for it:

```
class User < BaseModel
  table users do
    field name : String
    field age : Int32?
  end
end
```

### Field types

You can use the following types. More will be supported later.

* String
* Int32
* Email
* Time
* Bool

You can add a `?` to the end of any type to make it nilable.

## Querying the database

When you define a model, Lucky creates a query class that you can use to get
users from the database. The class is always called `{ModelName}::BaseQuery` .

To use it, let’s create a class that inherits from the one generated by Lucky.

```
class UserQuery < User::BaseQuery
end
```

`User::BaseQuery` has methods for querying and retrieving users

* `first`
* `each`
* `map`

It also has methods for ordering and adding where clauses. These are generated
based on the fields defined in your model.

For the model we defined previously Lucky would generate:

* created_at (automatically added)
* updated_at (automatically added)
* id (automatically added)
* age
* name

### Where clauses

You can use the methods generated by Lucky to create where clauses.

```
UserQuery.new.name(“Paul”)
UserQuery.new.age(28)
```

### Casting types

Lucky will accept the type defined in the model or a `String`. If you pass it a
`String` then Lucky will attempt to cast it to the type.

For example:

```
UserQuery.new.age("30") # will cast to an integer automatically
```

> Note that this will change in the future but this is the current behavior. In
the future only the defined type (`Int32` in this example) will work. You will
then need to manually cast it. Don’t worry though, Lucky will add some helpers
to actions and the model to make this easy and maintainable.

### Ordering results

````
UserQuery.new.age.desc_order
# or
UserQuery.new.age.asc_order
````

### Chaining methods

You can chain where clauses and most other query methods.

```
UserQuery.new.age.gt(28).age.desc_order
```

## Running the query

The query does not actually hit the database until a method is called to fetch a
result or iterate over results.

Some of the most common methods are:

* `first`
* `find`
* `each`

For example:

```
# The query is not yet run
query = UserQuery.new
query.name(“Sally”)
query.age(30)

# The query will run once each is called
query.each do |user|
  pp user.name
end
```

## Finding by ID

```
id = 1
UserQuery.new.find(id)

# You can also chain methods before calling find, first, etc.
UserQuery.new.age(30).find(1)
```

## Type specific query methods

The previous section mostly focused on simple equality queries, but you can also
do more advanced queries depending on the field type.

### All types

* `is`
* `desc_order`
* `asc_order`

### String

* `like`
* `ilike`
* `lower`

### Int32 and Time

* `gt`
* `gte`
* `lt`
* `lte`

### Examples

```
UserQuery.new.age.gte(18).name.lower.is("sally")
```

## Using scopes

Generally it’s best to name your query methods so they are easy to understand
and reuse across your app. In Lucky, this is done by extracting methods on the
query object.

Here’s an example:

```
class UserQuery < User::BaseQuery
  def adults
    age.gte(18)
  end

  def search(name)
    ilike("#{name}%")
  end
end

UserQuery.new.adults.search("Sal")
```

## Using associations

LuckyRecord currently has limited support for associations, but more features
will be added soon.

Right now you can define `has_many` and `belongs_to` associations.

```
class UserQuery < BaseModel
  table users do
    has_many tasks : Task
    belongs_to company : Company
  end
end

# Will return the company associated with the User
UserQuery.new.find(1).company
```

> Preloading associations to avoid N+1 queries will be coming soon.
