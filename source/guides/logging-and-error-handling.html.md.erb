---
title: Logging and Error Handling
order: 11
intro: >
  Logging your data and handling errors are two very important parts to developing your app.
  Lucky allows you to customize your log output, as well as choose how you want to handle your errors.
---

## Logging

By default, Lucky formats the log output to look like:

```text
GET /
 ▸ Handled by Home::Index
 ▸ Ran protect_from_forgery
 ▸ Ran sign_in_through_backdoor
 ▸ Rendered Lucky::WelcomePage
 ▸ Sent 200 (1.19ms)
```
This is broken down in to several parts.

* The HTTP request method and route
* The Lucky::Action handling the request
* Any before filters that need to be ran
* The page being rendered
* Finally the HTTP Status code and elapsed time

### Logger Options

Lucky uses [Dexter](https://github.com/luckyframework/dexter) for logging. You can change the logger configuration in `config/logger.cr`


## Log Formatters

To customize your logging output, you can create a custom Log Formatter. Open your `config/logger.cr` file and update the `log_formatter` option for `Dexter::Logger`.

```crystal
require "./log_formatters/my_custom_formatter"

Dexter::Logger.new(
  io: STDOUT,
  level: Logger::Severity::DEBUG,
  log_formatter: MyCustomFormatter
)
```

The structure for the formatters is a class that inherits from
`Dexter::Formatters::BaseLogFormatter` and defines the `format(data : NamedTuple)` method. Take a look at this example:

```crystal
class MyCustomFormatter < Dexter::Formatters::BaseLogFormatter
  def format(data : NamedTuple(status: Int32))
    case data[:status]
    when 200..399
      "😁"
    when 400..499
      "😱"
    when 500..599
      "😭"
    else
      "🧐"
    end
  end
end
```

## Error Handling

When an exception is thrown in your code, you don't want your user left with
a blank page, so Lucky has a built in way of handling these errors.

By default Lucky returns a 500 HTML page or JSON response.

### Customizing Error Handling

Let's say you have an error class `MyCustomError` in your app. When this
error is raised, you want to show a custom error to your users. Open up the
`Errors::Show` in `src/actions/errors/show.cr`, and add your `handle_error`
method like this.

```crystal
def handle_error(e : MyCustomError)
  if html?
    render_error_page title: "Custom error message.", status: 418
  else
    json({error: "Oh no!"})
  end
end
```

If there is no `handle_error` for the exception, it will fallback to the default
one that is generated with every Lucky project: `handle_error(e : Exception)`.
You can customize that method however you like!

### Error handling in development

When in development, Lucky uses the
[ExceptionPage](https://github.com/crystal-loot/exception_page) shard to
display a helpful page with your stack trace, and exception message. The
option to display the error page or not is in `config/error_handler.cr`.

If you need to see how the errors are handled in production (i.e. json
response for an api). Set the `settings.show_debug_output` option to `false`
in `config/log_handler.cr`.

### Default response codes for Exception classes

> In general this should be a last resort or for libraries that want to
provide default behavior. Usually you should use `handle_error` methods in
`Errors::Show` because it is far more customizable and much simpler to work with.

If you want to return a special http status code for an Exception class you can do this:

```crystal
# Define your custom exception
class NotAuthorizedError < Exception
  include Lucky::HttpRespondable

  def http_error_code
    403
  end
end
```

When `NotAuthorizedError` is raised, Lucky will use the defined status code, *unless*
you have a `handle_error` method that changes it.

## Error Reporting

There's many different services out there where you can ship your exceptions
off to for better cataloging and searching of the errors.

In your `src/actions/errors/show.cr` file, there are several different
`handle_error` methods. When an exception occurs in one of your actions, the
appropriate method is called passing in the exception. This gives you a
chance to report on the error however you like.

```crystal
# src/actions/errors/show.cr
def handle_error(error : MyCustomError)
  ErrorReporter.report(context, error)
  render Errors::ShowPage, status: 500, title: "Oops!"
end
```
